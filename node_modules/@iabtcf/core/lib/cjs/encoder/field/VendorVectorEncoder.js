"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.VendorVectorEncoder=void 0;const index_js_1=require("../../model/index.js"),index_js_2=require("../index.js"),IntEncoder_js_1=require("./IntEncoder.js"),BooleanEncoder_js_1=require("./BooleanEncoder.js"),FixedVectorEncoder_js_1=require("./FixedVectorEncoder.js"),VectorEncodingType_js_1=require("./VectorEncodingType.js"),index_js_3=require("../../errors/index.js");class VendorVectorEncoder{static encode(e){const n=[];let d,t=[],o=IntEncoder_js_1.IntEncoder.encode(e.maxId,index_js_2.BitLength.maxId),r="";const i=index_js_2.BitLength.maxId+index_js_2.BitLength.encodingType,s=i+e.maxId,_=2*index_js_2.BitLength.vendorId+index_js_2.BitLength.singleOrRange+index_js_2.BitLength.numEntries;let c=i+index_js_2.BitLength.numEntries;return e.forEach((o,i)=>{if(r+=BooleanEncoder_js_1.BooleanEncoder.encode(o),d=e.maxId>_&&c<s,d&&o){e.has(i+1)?0===t.length&&(t.push(i),c+=index_js_2.BitLength.singleOrRange,c+=index_js_2.BitLength.vendorId):(t.push(i),c+=index_js_2.BitLength.vendorId,n.push(t),t=[])}}),d?(o+=String(VectorEncodingType_js_1.VectorEncodingType.RANGE),o+=this.buildRangeEncoding(n)):(o+=String(VectorEncodingType_js_1.VectorEncodingType.FIELD),o+=r),o}static decode(e,n){let d,t=0;const o=IntEncoder_js_1.IntEncoder.decode(e.substr(t,index_js_2.BitLength.maxId),index_js_2.BitLength.maxId);t+=index_js_2.BitLength.maxId;const r=IntEncoder_js_1.IntEncoder.decode(e.charAt(t),index_js_2.BitLength.encodingType);if(t+=index_js_2.BitLength.encodingType,r===VectorEncodingType_js_1.VectorEncodingType.RANGE){if(d=new index_js_1.Vector,1===n){if("1"===e.substr(t,1))throw new index_js_3.DecodingError("Unable to decode default consent=1");t++}const o=IntEncoder_js_1.IntEncoder.decode(e.substr(t,index_js_2.BitLength.numEntries),index_js_2.BitLength.numEntries);t+=index_js_2.BitLength.numEntries;for(let n=0;n<o;n++){const n=BooleanEncoder_js_1.BooleanEncoder.decode(e.charAt(t));t+=index_js_2.BitLength.singleOrRange;const o=IntEncoder_js_1.IntEncoder.decode(e.substr(t,index_js_2.BitLength.vendorId),index_js_2.BitLength.vendorId);if(t+=index_js_2.BitLength.vendorId,n){const n=IntEncoder_js_1.IntEncoder.decode(e.substr(t,index_js_2.BitLength.vendorId),index_js_2.BitLength.vendorId);t+=index_js_2.BitLength.vendorId;for(let e=o;e<=n;e++)d.set(e)}else d.set(o)}}else{const n=e.substr(t,o);t+=o,d=FixedVectorEncoder_js_1.FixedVectorEncoder.decode(n,o)}return d.bitLength=t,d}static buildRangeEncoding(e){const n=e.length;let d=IntEncoder_js_1.IntEncoder.encode(n,index_js_2.BitLength.numEntries);return e.forEach(e=>{const n=1===e.length;d+=BooleanEncoder_js_1.BooleanEncoder.encode(!n),d+=IntEncoder_js_1.IntEncoder.encode(e[0],index_js_2.BitLength.vendorId),n||(d+=IntEncoder_js_1.IntEncoder.encode(e[1],index_js_2.BitLength.vendorId))}),d}}exports.VendorVectorEncoder=VendorVectorEncoder;